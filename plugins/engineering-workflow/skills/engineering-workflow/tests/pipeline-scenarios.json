[
  {
    "id": "PL-001",
    "description": "Single DB query — classify → tier LIGHT → validate → format",
    "query": "B-tree vs LSM storage engine comparison",
    "agent_output": {
      "rationale": "LSM-tree is optimal for write-heavy workloads due to sequential write patterns and efficient compaction",
      "recommendation": "Use RocksDB with level compaction for write-heavy workloads with acceptable read amplification trade-off",
      "confidence": 0.85,
      "trade_offs": [
        {"option": "LSM-tree", "pros": ["Write-optimized"], "cons": ["Read amplification"]},
        {"option": "B-tree", "pros": ["Read-optimized"], "cons": ["Write amplification"]}
      ],
      "constraints": [{"id": "c1", "target": "storage-engine", "value": "lsm", "priority": "hard"}]
    },
    "expected": {
      "classification_systems": ["DB"],
      "tier": "LIGHT",
      "validation_valid": true,
      "resolve_conflicts_count": 0,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-002",
    "description": "Cross-system DB+BE query — classify → tier THOROUGH → validate → format",
    "query": "shard database and update backend connection pool",
    "agent_output": {
      "systems_analyzed": ["DB", "BE"],
      "unified_recommendation": "Apply DB horizontal sharding using hash partitioning, then reconfigure BE connection pools with per-shard routing logic",
      "implementation_order": [
        {"phase": "db-sharding", "risk": "high", "rollback": "Revert to single-shard", "depends_on": []},
        {"phase": "be-pool-update", "risk": "low", "rollback": "", "depends_on": ["db-sharding"]}
      ],
      "cross_dependencies": [{"from": "DB", "to": "BE", "description": "Schema change requires repository updates"}],
      "confidence": 0.80
    },
    "expected": {
      "classification_systems": ["DB", "BE"],
      "tier": "THOROUGH",
      "validation_valid": true,
      "format_not_empty": true,
      "format_type": "cross-system"
    }
  },
  {
    "id": "PL-003",
    "description": "BE multi-cluster query — classify → tier STANDARD → validate → format",
    "query": "implement saga pattern with circuit breaker and tests",
    "agent_output": {
      "rationale": "Saga pattern with compensating transactions ensures eventual consistency across services, combined with circuit breaker for fault isolation",
      "recommendation": "Implement orchestration-based saga using Spring with Resilience4j circuit breaker at service boundaries and comprehensive test coverage",
      "confidence": 0.88,
      "trade_offs": [
        {"option": "Orchestration saga", "pros": ["Centralized control"], "cons": ["Single point of failure"]},
        {"option": "Choreography saga", "pros": ["Decoupled"], "cons": ["Hard to debug"]}
      ],
      "constraints": [{"id": "c1", "target": "saga-type", "value": "orchestration", "priority": "soft"}]
    },
    "expected": {
      "classification_systems": ["BE"],
      "classification_clusters": ["B", "R"],
      "tier": "STANDARD",
      "validation_valid": true,
      "resolve_conflicts_count": 0,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-004",
    "description": "Invalid agent output — should fail validation",
    "query": "database isolation level",
    "agent_output": {
      "confidence": 0.75
    },
    "expected": {
      "classification_systems": ["DB"],
      "tier": "LIGHT",
      "validation_valid": false,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-005",
    "description": "Security query — tier always THOROUGH",
    "query": "OAuth JWT token management",
    "agent_output": {
      "rationale": "JWT tokens should use RS256 signing with short expiry and refresh token rotation for security",
      "recommendation": "Implement OAuth 2.0 with JWT access tokens using RS256, 15-minute expiry, and secure refresh token rotation",
      "confidence": 0.82,
      "trade_offs": [
        {"option": "RS256", "pros": ["Asymmetric, verifiable"], "cons": ["Slightly slower"]},
        {"option": "HS256", "pros": ["Faster"], "cons": ["Shared secret risk"]}
      ],
      "constraints": [{"id": "c1", "target": "signing-algorithm", "value": "RS256", "priority": "hard"}]
    },
    "expected": {
      "classification_systems": ["SE"],
      "tier": "THOROUGH",
      "validation_valid": true,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-006",
    "description": "Summary format mode — compact output",
    "query": "B-tree vs LSM storage engine comparison",
    "agent_output": {
      "rationale": "LSM-tree is optimal for write-heavy workloads",
      "recommendation": "Use RocksDB with level compaction for optimal write performance in your use case scenario",
      "confidence": 0.85,
      "trade_offs": [
        {"option": "LSM-tree", "pros": ["Write-optimized"], "cons": ["Read amplification"]},
        {"option": "B-tree", "pros": ["Read-optimized"], "cons": ["Write amplification"]}
      ],
      "constraints": [{"id": "c1", "target": "storage-engine", "value": "lsm", "priority": "hard"}]
    },
    "expected": {
      "classification_systems": ["DB"],
      "format_summary": true,
      "format_contains": ["--summary"]
    }
  },
  {
    "id": "PL-007",
    "description": "IF-only query — classify → tier LIGHT → validate → format",
    "query": "kubernetes deployment monitoring with HPA",
    "agent_output": {
      "rationale": "HPA autoscaling with metrics-based triggers provides responsive scaling for variable workloads",
      "recommendation": "Configure HPA with custom metrics from Prometheus, set appropriate min/max replicas for the service",
      "confidence": 0.82
    },
    "expected": {
      "classification_systems": ["IF"],
      "tier": "LIGHT",
      "validation_valid": true,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-008",
    "description": "SE-only query — tier always THOROUGH",
    "query": "AES-256 encryption with key rotation using Vault",
    "agent_output": {
      "rationale": "AES-256-GCM with automated key rotation through HashiCorp Vault provides strong encryption with manageable key lifecycle",
      "recommendation": "Implement envelope encryption with Vault transit engine, rotate keys every 90 days with automated rotation policy",
      "confidence": 0.88,
      "constraints": [{"id": "c1", "target": "encryption-algorithm", "value": "aes-256-gcm", "priority": "hard"}]
    },
    "expected": {
      "classification_systems": ["SE"],
      "classification_se_clusters": ["E"],
      "tier": "THOROUGH",
      "validation_valid": true,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-009",
    "description": "4-system cross query — tier THOROUGH",
    "query": "security monitoring database api",
    "agent_output": {
      "systems_analyzed": ["DB", "BE", "IF", "SE"],
      "unified_recommendation": "Implement unified observability across all systems with security-first approach",
      "implementation_order": [
        {"phase": "security-audit", "risk": "high", "rollback": "Revert policies", "depends_on": []},
        {"phase": "monitoring-setup", "risk": "low", "rollback": "", "depends_on": ["security-audit"]}
      ],
      "confidence": 0.75
    },
    "expected": {
      "classification_systems": ["DB", "BE", "IF", "SE"],
      "tier": "THOROUGH",
      "validation_valid": true,
      "format_type": "cross-system",
      "format_not_empty": true
    }
  },
  {
    "id": "PL-010",
    "description": "Agent output with constraint conflict → resolve step",
    "query": "B-tree vs LSM storage engine comparison",
    "agent_output": {
      "rationale": "LSM-tree suits write-heavy, B-tree suits read-heavy workloads",
      "recommendation": "Choose based on primary workload pattern",
      "confidence": 0.85,
      "constraints": [
        {"id": "c1", "target": "storage-engine", "value": "lsm", "priority": "hard", "source_agent": "db/a1"},
        {"id": "c2", "target": "storage-engine", "value": "btree", "priority": "hard", "source_agent": "db/a2"}
      ]
    },
    "expected": {
      "classification_systems": ["DB"],
      "resolve_conflicts_count": 1,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-011",
    "description": "Korean query pipeline — classify + format",
    "query": "DynamoDB에서 TPS 5000+ 처리량 최적화",
    "agent_output": {
      "rationale": "DynamoDB 높은 TPS에서는 파티션 키 설계와 용량 모드 최적화가 핵심",
      "recommendation": "Write sharding으로 hot partition 방지 및 provisioned capacity with auto-scaling 적용",
      "confidence": 0.86
    },
    "expected": {
      "classification_systems": ["DB"],
      "classification_domains": ["F"],
      "tier": "LIGHT",
      "validation_valid": true,
      "format_not_empty": true
    }
  },
  {
    "id": "PL-012",
    "description": "No-match query — graceful degradation",
    "query": "hello world foo bar",
    "agent_output": {
      "rationale": "No engineering domain detected",
      "recommendation": "Please refine the query",
      "confidence": 0.10
    },
    "expected": {
      "classification_systems": [],
      "classification_pattern": "none",
      "validation_valid": true,
      "format_not_empty": true
    }
  }
]
